% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Conclusion}
\label{cap:conclusion}
\intro{This chapter provides a final discussion about the outcome of the whole research effort, considering also the \textbf{limitations} of the study design and findings, and the \textbf{recommandations for future research}.}

\section{Final assessment}
In this work, we investigated the feasibility of containerizing Legacy Game Engine modules and having them communicate with each other, with the purpose of implementing a Distributed Game Engine architecture. Our results show that it is indeed possible to containerize these modules and have them communicate with each other using various inter-container communication techniques. \\ \\
Moreover, we also explored the use of distributed databases as a solution for allowing consistent, but not necessarily quick, data communication between the Game Engine modules. We found that distributed databases can be a viable option for ensuring data consistency between modules, although their performance may not always meet the high-speed requirements of some gaming applications, such as TORCS. \\ \\
To this end, we compared the performance of Redis and ETCD in the context of a distributed version of TORCS. We found that Redis generally provided better framerate compared to ETCD, both in their standalone and 3-member cluster versions. This was evident in the various configurations that we tested, with Redis consistently delivering higher framerate than ETCD, in context where no latency is present. \\
Still, when network latency is introduced, ETCD's implementation of HTTP$_G$ pipelining may provide interesting benefits to mitigate the effect of delays on the single packets, especially in the stand-alone version of the systems, where their difference is not particularly pronounced. \\ \\
In the cluster versions of the systems, the difference in framerate between Redis and ETCD was particularly pronounced. Thanks to its Eventual Consistency mechanism, Redis was able to achieve significantly higher framerate than ETCD, indicating its superior performance in this setting. \\ \\
Overall, our results suggest that Redis is a more suitable choice for distributed applications that require high responsiveness, such as a distributed version of TORCS. On the other hand, ETCD may be more suitable for applications that require strong consistency and support for distributed transactions, but may not be as well-suited for high-performance applications. \\ \\
Working on an alternative solution, we implemented a State Manager middleware as a means of storing and distributing the state of a distributed version of TORCS. Our results showed that the State Manager was able to provide state storage and distribution without significantly impacting the performance of the system and with a generally moderate state inconsistency, in its Redis-based implementation. \\
Our experimental results demonstrated that the State Manager was able to provide fast and reliable state storage and distribution, with minimal impact on the framerate of the distributed version of TORCS. We also found that the State Manager was able to scale well with increasing numbers of cars, showing good performance even if with some graphics glitches. \\ \\
We also found that network latency has a noticeable impact on the performance of the distributed version of TORCS, leading to a significant degradation in framerate and a less enjoyable gameplay experience. This highlights the challenges of using distributed databases in these types of high-performance and latency-sensitive systems. \\
Despite the use of distributed databases optimized for fast and reliable data storage and retrieval, we found that they did not provide good performance when network latency was introduced. This suggests that more advanced techniques may be needed to effectively handle the high responsiveness requirements of TORCS in a distributed setting.

\section{Limitations}
While the tests conducted in this work were able to provide interesting insights into the performance of a TORCS distributed system based on shared storage, it is important to note that they were conducted in a local Docker environment, rather than a real-world Cloud$_G$ Computing scenario. This means that the results may not necessarily generalize to a production setting, where the system would be deployed on a Cloud$_G$ platform such as Amazon Web Services, Microsoft Azure or Kubernetes. \\ \\
A local Docker environment does not necessarily simulate the network latency and bandwidth constraints that are commonly encountered in a Cloud$_G$ environment. This can lead to differences in performance and resource utilization compared to a real-world context. \\ \\
One additional limitation is that only a few of the TORCS modules and libraries were containerized and incorporated into the final architecture. This means that this distributed version of TORCS is currently not complete, and only serves as a prototype for evaluating the feasibility of this approach. \\ \\
Finally, another limitation is that the State Manager middleware is limited in the amount of game state related data that it can store on the distributed database. The TORCS game state consists of a large amount of data, including information about the track, the cars, and their positions and velocities. In order to maintain a reasonable level of performance, the State Manager can only store a subset of this data on the distributed database. \\ \\
This means that the State Manager is not able to store the full game state at any given time, and some information may be lost or not accurately represented. This could potentially impact the accuracy and representation of the game, as well as generate graphics glitches in the distributed TORCS instances. \\ \\
Despite these limitations, this distributed version of TORCS and the related State Manager middleware developed during this project represent a significant step forward in the development of Distributed Game Engines.

\section{Recommandations for future research}
Considering the limitations we discussed in the previous section, there are multiple areas where future research can be conducted in order to provide interesting additional development. \\ \\
For instance, further work could be done to fully decompose the TORCS system architecture and address other aspects such as security and usability. Multiple additional libraries and modules of the original architecture may require considerable work to correctly manage all the reference present in the monolithic structure. Still, this effort is important to achieve a completely distributed version of TORCS. \\ \\
One area of further research that could be conducted in the development of a distributed version of TORCS is the use of alternative distributed databases. In this work, the State Manager middleware was developed using ETCD and Redis as the underlying distributed databases. However, there are many other distributed databases available that could potentially be used for this purpose, and could prove to be more fitting solutions, depending on their technical characteristics. \\ \\
As mentioned in the previous section, a possibly interesting development is the storage of the full TORCS game state into the distributed database, through the State Manager middleware. This might be difficult to realize with the solutions we currently evaluated, however newer or different approach may allows this kind of operation to be performed with reasonable performance. \\ \\
Finally, as we saw, network latency and bandwidth constraints can have a significant impact on performance and scalability of the TORCS distributed system. As such, there is much room for further research and innovation in the optimization of network communications. By improving the efficiency of the system's network communications, it may be possible to achieve even greater levels of performance and scalability.